1. class Solution {
    public int search(int[] nums, int target) {
        
    }
 int left = 0;
        int right = nums.length;
         (left < right) {
    
            int middle = left + (right - left) ;
            if (nums[middle] > nums[right]) {
                left = middle + 1;
            }
            
            else {
                right = middle;
            }
        }
        
        int pivot = left;
        left = 0;
        right = nums.length - 1;
        
        if (target >= nums[pivot] && target <= nums[right]) {
            left = pivot;
        } else {
            right = pivot;
        }
        while (left <= right) {
            int middle = left + (right - left) / 2;
            if (nums[middle] == target) {
                return middle;
            } else if (target < nums[middle]) {
                right = middle - 1;
            } else {
                left = middle + 1;
            }
        }
        return -1;
    }
}

2. class Solution {
    public int[] searchRange(int[] nums, int target) {
        int low = 0;
        int high = nums.size();
        
        int mid;
        
        while(low < high) {
            mid = (low + high)/2;
            if(nums[mid] >= target) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }
	
    vector<int> searchRange(vector<int>& nums, int target) {
        if(nums.size() == 0) return {-1,-1};

        int start = searchTheLowest(nums, target);
        int end = searchTheLowest(nums, target+1) - 1; // search for next big 
        
        if(start >= 0 && end >= 0 && start < nums.size() && end < nums.size() && nums[start] == target && nums[end] == target && start <= end) {
            return {start, end};
        }
        return {-1,-1};
    }
};
}

4. class SquareSortedArrayOptimized {
   
    public int[] sortedSquares(int[] A) {
        if (A == null) return null;
        int [] ans = new int[A.length];
        int start = 0, end = A.length - 1;
        
        int i = end; 
        while (start <= end) { 
            int pow1 = A[start] * A[start];
            int pow2 = A[end] * A[end];
            if (pow1 > pow2) {
                ans[i--] = pow1;
                start++;
            } else {
                ans[i--] = pow2;
                end--;
            }
        }

5. class Solution {
    public int maxIceCream(int[] costs, int coins) {
        sort(begin(costs), end(costs));
        int num = 0;
        for (int cost : costs) {
            if (coins >= cost) {
                num++;
                coins -= cost;
            } else {
                break;
            }
        }
        return num;
    }
};  }
}

6. class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s == null || s.equals("")) {
            return 0;
        }
        int start = 0;
        int end = 0;
        int maxLength = 0;
        Set<Character> uniqueCharacters = new HashSet<>();
        while (end < s.length()) {
            if (uniqueCharacters.add(s.charAt(end))) {
                end++;
                maxLength = Math.max(maxLength, uniqueCharacters.size());
            } else {
                uniqueCharacters.remove(s.charAt(start));
                start++;
            }
        }
        return maxLength;
    }
}   

7. class Solution {
    public int longestConsecutive(int[] num)
int findLongestConseqSubseq(int arr[], int n)
{
	int ans = 0, count = 0;
	sort(arr, arr + n);

	vector<int> v;
	v.push_back(arr[0]);
	for (int i = 1; i < n; i++)
	{
		if (arr[i] != arr[i - 1])
			v.push_back(arr[i]);
	}
	for (int i = 0; i < v.size(); i++)
	{
		if (i > 0 && v[i] == v[i - 1] + 1)
			count++;
		else
			count = 1;
		ans = max(ans, count);
	}
	return an
int main()
{
	int arr[] = { 1, 2, 2, 3 };
	int n = sizeof arr / sizeof arr[0];
	cout << "Length of the Longest contiguous subsequence "
			"is "
		<< findLongestConseqSubseq(arr, n);
	return 0;
}

8. class Solution {
    public int majorityElement(int[] nums) {
#include <bits/stdc++.h>
using namespace std;
void findMajority(int arr[], int n)
{
	int maxCount = 0;
	int index = -1; // sentinels
	for (int i = 0; i < n; i++) {
		int count = 0;
		for (int j = 0; j < n; j++) {
			if (arr[i] == arr[j])
				count++;
		}
		if (count > maxCount) {
			maxCount = count;
			index = i;
		}
	}

	if (maxCount > n / 2)
		cout << arr[index] << endl;

	else
		cout << "No Majority Element" << endl;
}
int main()
{
	int arr[] = { 1, 1, 2, 1, 3, 5, 1 };
	int n = sizeof(arr) / sizeof(arr[0]
	findMajority(arr, n);

	return 0;
 }
